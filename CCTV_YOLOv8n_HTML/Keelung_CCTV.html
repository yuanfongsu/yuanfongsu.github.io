<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>基隆市 CCTV 淹水監控儀表板</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f0f2f5; margin: 0; padding: 20px; }
        
        .header {
            text-align: center; margin-bottom: 20px;
            background: white; padding: 15px; border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        h1 { margin: 0; color: #2c3e50; font-weight: 300; font-size: 24px; }
        .stats { color: #7f8c8d; margin-top: 5px; font-size: 13px; font-weight: bold; }
        
        .controls { text-align: center; margin-bottom: 20px; display: flex; justify-content: center; gap: 10px; align-items: center; }
        button {
            padding: 8px 16px; font-size: 14px; border: none; border-radius: 6px;
            cursor: pointer; background-color: #3498db; color: white; font-weight: bold;
            transition: all 0.3s; box-shadow: 0 4px 6px rgba(52, 152, 219, 0.2);
        }
        button:hover { background-color: #2980b9; transform: translateY(-1px); }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; transform: none; box-shadow: none; }
        
        #btn-auto { background-color: #8e44ad; }
        #btn-auto:hover { background-color: #9b59b6; }
        #btn-stop { background-color: #e74c3c; }
        #btn-stop:hover { background-color: #c0392b; }

        .timer-display { font-weight: bold; color: #e67e22; margin-left: 15px; font-size: 14px; min-width: 120px; text-align: left; }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 10px;
        }
        
        .card {
            background: white; border-radius: 8px; overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            display: flex; flex-direction: column;
            border: 1px solid #eee;
        }
        
        .card-header {
            padding: 8px 10px; border-bottom: 1px solid #f0f0f0;
            display: flex; justify-content: space-between; align-items: center;
            background: #fdfdfd;
        }
        .card-title { 
            font-weight: bold; font-size: 12px; color: #333; 
            overflow: hidden; white-space: nowrap; text-overflow: ellipsis; 
            max-width: 100px; 
        }
        .card-id { font-size: 10px; color: #999; background: #eee; padding: 1px 4px; border-radius: 4px; }
        
        .card-body {
            position: relative;
            height: 120px;
            background-color: #eee;
            display: flex; align-items: center; justify-content: center;
        }
        
        .cctv-img {
            width: 100%; height: 100%; object-fit: contain;
            background: black;
            display: none;
        }
        
        .placeholder { color: #aaa; font-size: 11px; display: flex; flex-direction: column; align-items: center; }
        
        .status-bar { padding: 4px 0; font-size: 11px; font-weight: bold; text-align: center; border-top: 1px solid #eee; }
        .status-waiting { background-color: #f8f9fa; color: #7f8c8d; }
        .status-scanning { background-color: #fff3cd; color: #856404; }
        .status-safe { background-color: #d4edda; color: #155724; }
        .status-flood { background-color: #f8d7da; color: #721c24; animation: flash 2s infinite; }
        .status-error { background-color: #e2e3e5; color: #383d41; }
        
        @keyframes flash { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

        #hidden-processor { display: none; }
    </style>
</head>
<body>

    <div class="header">
        <h1>基隆市 CCTV 淹水監控 (Python Local)</h1>
        <div class="stats">
            共監控 <span id="total-count">0</span> 處測站 | 
            <span style="color:#27ae60">● 安全: <span id="safe-count">0</span></span> | 
            <span style="color:#c0392b">● 淹水: <span id="flood-count">0</span></span> | 
            <span style="color:#7f8c8d">● 待機: <span id="waiting-count">0</span></span>
        </div>
        <div id="model-status" style="margin-top:5px; font-size:12px; font-weight:bold; color:#e67e22;">正在載入 AI 模型...</div>
    </div>

    <div class="controls">
        <button id="btn-start" onclick="startBatchScan()">單次掃描</button>
        <button id="btn-auto" onclick="toggleAutoScan()">啟動自動監控 (10分)</button>
        <button id="btn-stop" onclick="stopScan()">停止</button>
        <span id="timer-display" class="timer-display"></span>
    </div>

    <div class="grid-container" id="grid">
        </div>

    <div id="hidden-processor">
        <img id="processor-img" crossorigin="anonymous">
        <canvas id="processor-canvas"></canvas>
    </div>

    <script>
        // ================= 1. DATA (CSV) =================
        const cctvList = [{"id": "T000002", "name": "基金一路 基金交流道下匝道", "url": "https://CCTV.KLCG.GOV.TW:443/9cc4ca1c", "lat": 25.13972, "lon": 121.71492}, {"id": "T000003", "name": "中正路 祥豐街 豐稔路", "url": "https://CCTV.KLCG.GOV.TW:443/41b0eff2", "lat": 25.14195, "lon": 121.76052}, {"id": "T000005", "name": "源遠路 暖暖交流道", "url": "https://CCTV.KLCG.GOV.TW:443/e39b2843", "lat": 25.10476, "lon": 121.73497}, {"id": "T000007", "name": "東信路 崇法街", "url": "https://CCTV.KLCG.GOV.TW:443/facd4662", "lat": 25.12823, "lon": 121.76443}, {"id": "T000008", "name": "明德一路 大華橋頭", "url": "https://CCTV.KLCG.GOV.TW:443/fe38304c", "lat": 25.09992, "lon": 121.71926}, {"id": "T000009", "name": "八堵路 源遠路", "url": "https://CCTV.KLCG.GOV.TW:443/ad17e061", "lat": 25.10888, "lon": 121.73148}, {"id": "T000012", "name": "明德一路 光明路 (往台北)", "url": "https://CCTV.KLCG.GOV.TW:443/bf14f2af", "lat": 25.09941, "lon": 121.71762}, {"id": "T000014", "name": "孝二路 忠四路", "url": "https://CCTV.KLCG.GOV.TW:443/70cf7bac", "lat": 25.1283, "lon": 121.73919}, {"id": "T000015", "name": "中正路 信一路", "url": "https://CCTV.KLCG.GOV.TW:443/55c38316", "lat": 25.13135, "lon": 121.74341}, {"id": "T000016", "name": "正信路 信一路", "url": "https://CCTV.KLCG.GOV.TW:443/6972615b", "lat": 25.1286, "lon": 121.7602}, {"id": "T000018", "name": "北寧路 祥豐路 (祥豐)", "url": "https://cctv.klcg.gov.tw/582d9c95", "lat": 25.15075, "lon": 121.77225}, {"id": "T000019", "name": "北寧路 祥豐街(中正)", "url": "https://cctv.klcg.gov.tw/64253e5c", "lat": 25.15102, "lon": 121.77206}, {"id": "T000020", "name": "中正路 祥豐街(北寧)", "url": "https://cctv.klcg.gov.tw/d2fd095d", "lat": 25.15103, "lon": 121.77245}, {"id": "T000021", "name": "中山一路 成功二路", "url": "https://CCTV.KLCG.GOV.TW:443/bf0ed2e8", "lat": 25.12935, "lon": 121.73631}, {"id": "T000022", "name": "中山一路 港西高架", "url": "https://CCTV.KLCG.GOV.TW:443/a1951422", "lat": 25.13424, "lon": 121.73949}, {"id": "T000023", "name": "中正路 義一路", "url": "https://CCTV.KLCG.GOV.TW:443/fe7f8d20", "lat": 25.13699, "lon": 121.74808}, {"id": "T000024", "name": "仁二路 愛三路", "url": "https://CCTV.KLCG.GOV.TW:443/f29f13e0", "lat": 25.12955, "lon": 121.74347}, {"id": "T000026", "name": "忠一路 孝二路", "url": "https://CCTV.KLCG.GOV.TW:443/1c8ebc07", "lat": 25.13096, "lon": 121.74098}, {"id": "T000027", "name": "基金一路/二路1巷/台62匝道口", "url": "https://CCTV.KLCG.GOV.TW:443/a4fbca47", "lat": 25.14209, "lon": 121.70344}, {"id": "T000030", "name": "大武崙工業區口 基金二路14號", "url": "https://CCTV.KLCG.GOV.TW:443/79735f24", "lat": 25.14886, "lon": 121.69994}, {"id": "T000031", "name": "基金一路 基金交流道", "url": "https://CCTV.KLCG.GOV.TW:443/afc440ef", "lat": 25.1401, "lon": 121.7134}, {"id": "T000032", "name": "基金三路 基金三路56號", "url": "https://CCTV.KLCG.GOV.TW:443/6613ea0b", "lat": 25.15214, "lon": 121.6975}, {"id": "T000033", "name": "中山二路 海三廠", "url": "https://CCTV.KLCG.GOV.TW:443/f40905ec", "lat": 25.14474, "lon": 121.73888}, {"id": "T000034", "name": "台62甲匝道 東海街", "url": "https://cctv.klcg.gov.tw/cce885d5", "lat": 25.13962, "lon": 121.75274}, {"id": "T000036", "name": "實踐路253巷 堵南街", "url": "https://CCTV.KLCG.GOV.TW:443/d732959c", "lat": 25.08376, "lon": 121.68381}, {"id": "T000037", "name": "中山一路 忠一路", "url": "https://cctv.klcg.gov.tw/4e6b2984", "lat": 25.13235, "lon": 121.73828}, {"id": "T000038", "name": "仁一路 愛三路", "url": "https://cctv.klcg.gov.tw/48603956", "lat": 25.1305, "lon": 121.74399}, {"id": "T000039", "name": "中正路/正濱路(北)", "url": "https://CCTV.KLCG.GOV.TW:443/1098d034", "lat": 25.15191, "lon": 121.77018}, {"id": "T000040", "name": "中正路/正濱路(西)", "url": "https://CCTV.KLCG.GOV.TW:443/8edd00b1", "lat": 25.1519, "lon": 121.77015}, {"id": "T000041", "name": "中正路/正濱路(東)", "url": "https://CCTV.KLCG.GOV.TW:443/779d5831", "lat": 25.15188, "lon": 121.77018}, {"id": "T000042", "name": "港西街 台鐵北站", "url": "https://CCTV.KLCG.GOV.TW:443/01d5a434", "lat": 25.13473, "lon": 121.74062}, {"id": "T000043", "name": "中山一路 港西街", "url": "https://CCTV.KLCG.GOV.TW:443/a6897937", "lat": 25.13602, "lon": 121.74092}, {"id": "T000044", "name": "仁二路 愛六路", "url": "https://CCTV.KLCG.GOV.TW:443/05c7e2d9", "lat": 25.12743, "lon": 121.74724}, {"id": "T000045", "name": "中山二路36巷", "url": "https://CCTV.KLCG.GOV.TW:443/a22c3d9d", "lat": 25.13803, "lon": 121.74063}, {"id": "T000046", "name": "信二路 義四路", "url": "https://CCTV.KLCG.GOV.TW:443/5dc09fe8", "lat": 25.13004, "lon": 121.74832}, {"id": "T000047", "name": "麥金路 長庚醫院", "url": "https://CCTV.KLCG.GOV.TW:443/ed3956e0", "lat": 25.12076, "lon": 121.72193}, {"id": "T000048", "name": "台62甲 孝東路(東)", "url": "https://CCTV.KLCG.GOV.TW:443/86dd979f", "lat": 25.12809, "lon": 121.77824}, {"id": "T000049", "name": "台62甲 孝東路(南)", "url": "https://CCTV.KLCG.GOV.TW:443/31fb51dc", "lat": 25.12765, "lon": 121.77777}, {"id": "T000050", "name": "台62甲 孝東路(西)", "url": "https://CCTV.KLCG.GOV.TW:443/e34dd3c2", "lat": 25.12811, "lon": 121.77698}, {"id": "T000051", "name": "台62甲 孝東路(北)", "url": "https://CCTV.KLCG.GOV.TW:443/b97b5980", "lat": 25.12838, "lon": 121.77733}, {"id": "T000052", "name": "孝東路 深溪路 深澳坑路 (北)", "url": "https://CCTV.KLCG.GOV.TW:443/e396f4c8", "lat": 25.12861, "lon": 121.78055}, {"id": "T000053", "name": "孝東路 深溪路 深澳坑路 (東)", "url": "https://CCTV.KLCG.GOV.TW:443/2df67f02", "lat": 25.12844, "lon": 121.78055}, {"id": "T000054", "name": "孝東路 深溪路 深澳坑路 (西)", "url": "https://CCTV.KLCG.GOV.TW:443/8ec8cebd", "lat": 25.12838, "lon": 121.78024}, {"id": "T000055", "name": "孝東路 深溪路 深澳坑路 (西北)", "url": "https://CCTV.KLCG.GOV.TW:443/b872ad93", "lat": 25.12855, "lon": 121.78034}, {"id": "T000056", "name": "麥金路 基金一路", "url": "https://CCTV.KLCG.GOV.TW:443/8a2f8b58", "lat": 25.13562, "lon": 121.72174}, {"id": "T000057", "name": "安一路 西定路", "url": "https://CCTV.KLCG.GOV.TW:443/108ffee4", "lat": 25.13169, "lon": 121.73542}, {"id": "T000058", "name": "北寧路 369巷", "url": "https://cctv.klcg.gov.tw/85aa691f", "lat": 25.1402, "lon": 121.79991}, {"id": "T000059", "name": "德安路 復興路 新橫濱", "url": "https://CCTV.KLCG.GOV.TW:443/6c944104", "lat": 25.14878, "lon": 121.72586}, {"id": "T000060", "name": "中正路 北寧路 祥豐街(東)", "url": "https://CCTV.KLCG.GOV.TW:443/47668ccf", "lat": 25.15101, "lon": 121.77249}, {"id": "T000061", "name": "中正路 北寧路 祥豐街(東南)", "url": "https://CCTV.KLCG.GOV.TW:443/d6dee07c", "lat": 25.15071, "lon": 121.7723}, {"id": "T006940", "name": "麥金路 樂利三路", "url": "https://CCTV.KLCG.GOV.TW:443/15c4860f", "lat": 25.12837, "lon": 121.71997}, {"id": "T010931", "name": "正濱路 正濱路166巷口", "url": "https://CCTV.KLCG.GOV.TW:443/cc6b56ab", "lat": 25.15341, "lon": 121.76915}, {"id": "T015730", "name": "德安路 復興路", "url": "https://CCTV.KLCG.GOV.TW:443/7a0cfa17", "lat": 25.15, "lon": 121.725}, {"id": "T202400", "name": "調和街 深澳坑路", "url": "https://CCTV.KLCG.GOV.TW:443/2509bb1d", "lat": 25.11975, "lon": 121.79764}, {"id": "T202900", "name": "北寧路 調和街", "url": "https://CCTV.KLCG.GOV.TW:443/c78e20a2", "lat": 25.1394, "lon": 121.79624}, {"id": "T203170", "name": "深澳坑路 深溪路", "url": "https://CCTV.KLCG.GOV.TW:443/123f54a1", "lat": 25.12853, "lon": 121.78044}, {"id": "T203300", "name": "復興路 中和路", "url": "https://CCTV.KLCG.GOV.TW:443/98a31378", "lat": 25.14401, "lon": 121.72592}, {"id": "T203520", "name": "堵南路 千祥橋頭", "url": "https://cctv.klcg.gov.tw/24c20536", "lat": 25.0825, "lon": 121.68477}, {"id": "T204820", "name": "湖海路 外木山風景區", "url": "https://CCTV.KLCG.GOV.TW:443/46c063f1", "lat": 25.163, "lon": 121.7261}, {"id": "T205130", "name": "中山一路 中華路", "url": "https://CCTV.KLCG.GOV.TW:443/cbbaa7d5", "lat": 25.14605, "lon": 121.7387}];
        
        // ================= 2. CONFIG =================
        const MODEL_URL = './best_web_model/model.json';
        const MODEL_INPUT_SIZE = 320; 
        const CONFIDENCE_THRESHOLD = 0.8; 
        const LINE_THICKNESS = 2;
        const AUTO_INTERVAL_SEC = 600; // 10 minutes
        
        // ================= 3. STATE =================
        let model;
        let isScanning = false;
        let shouldStop = false;
        let isAutoMode = false;
        let countdownTimerId = null;
        
        const stats = { safe: 0, flood: 0, waiting: cctvList.length };
        const sigmoid = (x) => 1 / (1 + Math.exp(-x));

        // ================= 4. INITIALIZATION =================
        function init() {
            const grid = document.getElementById('grid');
            document.getElementById('total-count').innerText = cctvList.length;
            document.getElementById('waiting-count').innerText = cctvList.length;

            cctvList.forEach((cctv, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.id = `card-${index}`;
                
                card.innerHTML = `
                    <div class="card-header">
                        <span class="card-title" title="${cctv.name}">${cctv.name}</span>
                        <span class="card-id">${cctv.id}</span>
                    </div>
                    <div class="card-body" id="body-${index}">
                        <div class="placeholder">
                            <span>等待掃描...</span>
                        </div>
                        <img class="cctv-img" id="img-${index}">
                    </div>
                    <div class="status-bar status-waiting" id="status-${index}">等待中</div>
                `;
                grid.appendChild(card);
            });

            loadModel();
        }

        async function loadModel() {
            const statusEl = document.getElementById('model-status');
            try {
                model = await tf.loadGraphModel(MODEL_URL);
                const dummy = tf.zeros([1, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE, 3]);
                model.execute(dummy);
                tf.dispose(dummy);
                statusEl.innerHTML = "<span style='color:green'>✔ 模型已就緒</span>";
                document.getElementById('btn-start').disabled = false;
                document.getElementById('btn-auto').disabled = false;
            } catch (error) {
                console.error(error);
                statusEl.innerHTML = "<span style='color:red'>✘ 模型載入失敗 (請確認路徑)</span>";
            }
        }

        // ================= 5. SCANNING & AUTO LOGIC =================
        function toggleAutoScan() {
            const btnAuto = document.getElementById('btn-auto');
            if (isAutoMode) {
                isAutoMode = false;
                btnAuto.innerText = "啟動自動監控 (10分)";
                btnAuto.style.backgroundColor = "#8e44ad";
                stopScan();
            } else {
                isAutoMode = true;
                btnAuto.innerText = "停止自動監控";
                btnAuto.style.backgroundColor = "#27ae60"; 
                startBatchScan();
            }
        }

        async function startBatchScan() {
            if (isScanning) return;
            isScanning = true;
            shouldStop = false;
            
            document.getElementById('btn-start').disabled = true;
            document.getElementById('timer-display').innerText = "";
            clearInterval(countdownTimerId);

            stats.safe = 0; stats.flood = 0; stats.waiting = cctvList.length;
            updateStats();

            for (let i = 0; i < cctvList.length; i++) {
                if (shouldStop) break;
                updateCardStatus(i, 'scanning');
                await processCCTV(cctvList[i], i);
                await new Promise(r => setTimeout(r, 200));
            }
            
            isScanning = false;
            
            if (isAutoMode && !shouldStop) {
                startCountdown(AUTO_INTERVAL_SEC);
            } else {
                document.getElementById('btn-start').disabled = false;
                document.getElementById('btn-start').innerText = "單次全網掃描";
                if(isAutoMode) toggleAutoScan();
            }
        }

        function startCountdown(seconds) {
            const display = document.getElementById('timer-display');
            let remaining = seconds;
            display.innerText = `下次掃描: ${remaining}秒`;
            
            countdownTimerId = setInterval(() => {
                remaining--;
                display.innerText = `下次掃描: ${remaining}秒`;
                if (remaining <= 0) {
                    clearInterval(countdownTimerId);
                    startBatchScan();
                }
            }, 1000);
        }

        function stopScan() {
            shouldStop = true;
            isScanning = false;
            clearInterval(countdownTimerId);
            document.getElementById('timer-display').innerText = "已停止";
            if (isAutoMode) {
                isAutoMode = false;
                const btnAuto = document.getElementById('btn-auto');
                btnAuto.innerText = "啟動自動監控 (10分)";
                btnAuto.style.backgroundColor = "#8e44ad";
            }
            document.getElementById('btn-start').disabled = false;
        }

        async function processCCTV(cctv, index) {
            try {
                const processorImg = document.getElementById('processor-img');
                
                // 1. 載入圖片
                await loadImage(processorImg, cctv.url);
                
                // 2. 獲取原圖 Base64 (用於存檔)
                // 我們創建一個暫時的 canvas 來取得原圖的 Base64
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = processorImg.naturalWidth;
                tempCanvas.height = processorImg.naturalHeight;
                tempCanvas.getContext('2d').drawImage(processorImg, 0, 0);
                const originalBase64 = tempCanvas.toDataURL('image/jpeg');

                // 3. 執行推論
                const result = await runYoloSegmentation(processorImg);
                
                // 4. 更新 UI
                const displayImg = document.getElementById(`img-${index}`);
                displayImg.src = result.dataUrl;
                displayImg.style.display = 'block';
                const body = document.getElementById(`body-${index}`);
                const placeholder = body.querySelector('.placeholder');
                if(placeholder) placeholder.style.display = 'none';

                if (result.hasFlood) {
                    updateCardStatus(index, 'flood');
                    // 5. 【新增】 如果淹水，發送圖片到後端存檔
                    await saveAlertToServer(cctv.name, originalBase64, result.dataUrl);
                } else {
                    updateCardStatus(index, 'safe');
                }

            } catch (err) {
                console.warn(`CCTV ${cctv.id} failed`, err);
                updateCardStatus(index, 'error');
            }
        }

        // 【新增】傳送警報到後端
        async function saveAlertToServer(name, originalB64, labeledB64) {
            try {
                const response = await fetch('http://localhost:5000/save_alert', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: name,
                        image_original: originalB64,
                        image_labeled: labeledB64
                    })
                });
                const res = await response.json();
                console.log("Alert saved:", res);
            } catch (e) {
                console.error("Failed to save alert:", e);
            }
        }

        function updateCardStatus(index, status) {
            const statusBar = document.getElementById(`status-${index}`);
            statusBar.className = 'status-bar'; 
            if (status === 'scanning') {
                statusBar.classList.add('status-scanning');
                statusBar.innerText = "掃描中...";
            } else if (status === 'safe') {
                statusBar.classList.add('status-safe');
                statusBar.innerText = "✔ 安全";
                stats.safe++;
                stats.waiting--;
            } else if (status === 'flood') {
                statusBar.classList.add('status-flood');
                statusBar.innerText = "⚠ 淹水警報";
                stats.flood++;
                stats.waiting--;
            } else if (status === 'error') {
                statusBar.classList.add('status-error');
                statusBar.innerText = "讀取失敗";
                stats.waiting--;
            }
            updateStats();
        }

        function updateStats() {
            document.getElementById('safe-count').innerText = stats.safe;
            document.getElementById('flood-count').innerText = stats.flood;
            document.getElementById('waiting-count').innerText = Math.max(0, stats.waiting);
        }

        function loadImage(img, url) {
            return new Promise((resolve, reject) => {
                const LOCAL_PROXY = "http://localhost:5000/proxy?url=";
                img.crossOrigin = "Anonymous";
                img.onload = () => resolve();
                img.onerror = () => reject(new Error("Image Load Failed"));
                img.src = LOCAL_PROXY + encodeURIComponent(url);
            });
        }

        // ================= 6. YOLO LOGIC =================
        async function runYoloSegmentation(imageElement) {
            const canvas = document.getElementById('processor-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = imageElement.naturalWidth || 640;
            canvas.height = imageElement.naturalHeight || 480;
            ctx.drawImage(imageElement, 0, 0, canvas.width, canvas.height);
            
            const tfImg = tf.browser.fromPixels(imageElement)
                .resizeNearestNeighbor([MODEL_INPUT_SIZE, MODEL_INPUT_SIZE])
                .toFloat()
                .div(tf.scalar(255.0))
                .expandDims();
                
            let hasFlood = false;

            try {
                const results = model.execute(tfImg);
                let output0, output1;
                
                if (Array.isArray(results)) {
                    output0 = results[0].shape.length === 3 ? results[0] : results[1];
                    output1 = results[0].shape.length === 3 ? results[1] : results[0];
                } else {
                    tfImg.dispose();
                    return { hasFlood: false, dataUrl: canvas.toDataURL() };
                }

                const squeezed = output0.squeeze();
                const transposed = squeezed.transpose([1, 0]);
                const boxesData = await transposed.array();
                
                const candidates = [];
                for (let i = 0; i < boxesData.length; i++) {
                    let score = boxesData[i][4];
                    if (score > 1.0) score = sigmoid(score);
                    if (score > CONFIDENCE_THRESHOLD) {
                        const [cx, cy, w, h] = boxesData[i].slice(0, 4);
                        candidates.push({ index: i, score: score });
                    }
                }

                if (candidates.length > 0) {
                    hasFlood = true;
                    
                    const protoTensor = output1.squeeze();
                    const pShape = protoTensor.shape;
                    let maskMat, protoH, protoW;
                    
                    if (pShape[0] === 32) {
                        protoH = pShape[1]; protoW = pShape[2];
                        maskMat = protoTensor.reshape([32, protoH * protoW]).transpose(); 
                    } else {
                        protoH = pShape[0]; protoW = pShape[1];
                        maskMat = protoTensor.reshape([protoH * protoW, 32]);
                    }

                    for (let c of candidates) {
                        const data = boxesData[c.index];
                        const maskCoeffs = data.slice(5, 5 + 32);
                        const coeffsTensor = tf.tensor2d(maskCoeffs, [32, 1]);
                        const maskFlat = maskMat.matMul(coeffsTensor);
                        const maskActivated = tf.sigmoid(maskFlat);
                        const maskImg = maskActivated.reshape([protoH, protoW]);

                        const maskCanvas = document.createElement('canvas');
                        maskCanvas.width = protoW; maskCanvas.height = protoH;
                        await tf.browser.toPixels(maskImg, maskCanvas);
                        
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = canvas.width; tempCanvas.height = canvas.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.imageSmoothingEnabled = true;
                        tempCtx.drawImage(maskCanvas, 0, 0, tempCanvas.width, tempCanvas.height);
                        
                        const pixels = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;
                        const outputData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const outPixels = outputData.data;
                        const w = canvas.width; const h = canvas.height;
                        
                        const edgePoints = [];
                        let sumX = 0, sumY = 0, count = 0;

                        for (let y = 1; y < h - 1; y++) {
                            for (let x = 1; x < w - 1; x++) {
                                const idx = (y * w + x) * 4;
                                if (pixels[idx] > 128) {
                                    sumX += x; sumY += y; count++;
                                    if (pixels[((y-1)*w+x)*4] <= 128 || pixels[((y+1)*w+x)*4] <= 128 ||
                                        pixels[(y*w+(x-1))*4] <= 128 || pixels[(y*w+(x+1))*4] <= 128) {
                                        edgePoints.push({x, y});
                                    }
                                }
                            }
                        }

                        const r=255, g=230, b=0, a=255;
                        for (let pt of edgePoints) {
                            for (let dy = -LINE_THICKNESS; dy <= LINE_THICKNESS; dy++) {
                                for (let dx = -LINE_THICKNESS; dx <= LINE_THICKNESS; dx++) {
                                    const nx = pt.x + dx; const ny = pt.y + dy;
                                    if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                        const nIdx = (ny * w + nx) * 4;
                                        outPixels[nIdx] = r; outPixels[nIdx+1] = g; outPixels[nIdx+2] = b; outPixels[nIdx+3] = a;
                                    }
                                }
                            }
                        }
                        ctx.putImageData(outputData, 0, 0);

                        if (count > 0) {
                            const cx = sumX / count;
                            const cy = sumY / count;
                            const fontSize = Math.max(14, Math.floor(w * 0.03));
                            const padding = fontSize * 0.4;

                            ctx.font = `bold ${fontSize}px Arial`;
                            const txt = `${Math.round(c.score * 100)}%`;
                            const txtW = ctx.measureText(txt).width;
                            const txtH = fontSize;

                            ctx.fillStyle = "rgba(255, 230, 0, 0.9)";
                            ctx.fillRect(cx - txtW/2 - padding, cy - txtH/2 - padding, txtW + padding*2, txtH + padding*2);
                            ctx.fillStyle = "#000";
                            ctx.textBaseline = "middle";
                            ctx.fillText(txt, cx - txtW/2, cy);
                        }
                        tf.dispose([coeffsTensor, maskFlat, maskActivated, maskImg]);
                    }
                    tf.dispose([protoTensor, maskMat]);
                }
                
                tf.dispose([output0, output1, squeezed, transposed]);

            } catch (e) {
                console.error(e);
            } finally {
                tfImg.dispose();
            }

            return { hasFlood, dataUrl: canvas.toDataURL() };
        }

        init();
    </script>
</body>
</html>
