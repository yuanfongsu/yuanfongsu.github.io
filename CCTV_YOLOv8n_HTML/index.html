<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 淹水分割 (多物件+粗線條)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>

    <style>
        /* --- 優雅風格 (White Theme) --- */
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            background-color: #ffffff;
            color: #333;
            margin: 0;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 { font-weight: 300; margin-bottom: 10px; color: #2c3e50; }

        .main-container {
            width: 95%;
            max-width: 1000px;
            background: #fff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
            text-align: center;
        }

        .controls { margin: 20px 0; display: flex; gap: 15px; justify-content: center; }

        button, input[type="file"]::file-selector-button {
            background-color: #f8f9fa; border: 1px solid #e2e6ea; border-radius: 6px;
            padding: 10px 20px; font-size: 14px; cursor: pointer; transition: all 0.2s ease; color: #555;
        }
        button:hover, input[type="file"]::file-selector-button:hover { background-color: #e9ecef; color: #333; }
        button.primary { background-color: #333; color: #fff; border: none; }
        button.primary:hover { background-color: #555; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .status { margin-top: 15px; font-size: 14px; color: #666; min-height: 20px; }

        .comparison-container {
            display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-top: 30px;
        }

        .img-wrapper {
            flex: 1; min-width: 300px; max-width: 450px;
            display: flex; flex-direction: column; align-items: center;
        }

        .img-box {
            width: 100%; min-height: 200px;
            border: 2px dashed #eee; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden; padding: 10px; background: #fafafa;
        }

        .img-label { font-weight: bold; margin-bottom: 8px; color: #555; }

        img#preview, canvas#result-canvas {
            max-width: 100%; max-height: 250px; display: none; border-radius: 4px; object-fit: contain;
        }
        canvas#result-canvas { box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    </style>
</head>
<body>

    <div class="main-container">
        <h1>AI 淹水分割 (多區域 + 信心標示)</h1>
        <p style="color:#888; font-size: 0.9em;">支援多個淹水區塊，並加粗顯示邊緣</p>

        <div class="controls">
            <input type="file" id="uploadInput" accept="image/*">
            <button class="primary" id="detectBtn" onclick="runDetection()" disabled>開始分析</button>
        </div>

        <div class="status" id="statusText">等待模型載入...</div>

        <div class="comparison-container">
            <div class="img-wrapper">
                <div class="img-label">原始圖片</div>
                <div class="img-box">
                    <span id="placeholder-left" style="color: #ccc;">預覽圖</span>
                    <img id="preview" alt="Original Image" />
                </div>
            </div>

            <div class="img-wrapper">
                <div class="img-label">偵測結果</div>
                <div class="img-box">
                    <span id="placeholder-right" style="color: #ccc;">等待執行...</span>
                    <canvas id="result-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ================= 設定區 =================
        const MODEL_URL = './best_web_model/model.json';
        const MODEL_INPUT_SIZE = 320; 
        const CONFIDENCE_THRESHOLD = 0.3; // 信心門檻 (降低一點以顯示更多區塊)
        const IOU_THRESHOLD = 0.4;        // NMS 重疊門檻
        const LINE_THICKNESS = 2;         // 線條粗細 (數值越大越粗，2 代表 5x5 的粗度)
        // ==========================================

        let model;
        const statusText = document.getElementById('statusText');
        const uploadInput = document.getElementById('uploadInput');
        const previewImg = document.getElementById('preview');
        const resultCanvas = document.getElementById('result-canvas');
        const detectBtn = document.getElementById('detectBtn');
        const placeholderLeft = document.getElementById('placeholder-left');
        const placeholderRight = document.getElementById('placeholder-right');

        const sigmoid = (x) => 1 / (1 + Math.exp(-x));

        async function loadModel() {
            try {
                statusText.innerText = "正在載入模型...";
                model = await tf.loadGraphModel(MODEL_URL);
                
                const dummy = tf.zeros([1, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE, 3]);
                model.execute(dummy);
                tf.dispose(dummy);

                console.log("模型載入成功");
                statusText.innerText = "模型準備就緒，請上傳圖片。";
                detectBtn.disabled = false;
            } catch (error) {
                console.error("載入失敗:", error);
                statusText.innerText = "錯誤：無法載入模型";
            }
        }
        loadModel();

        uploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    previewImg.src = e.target.result;
                    previewImg.style.display = 'block';
                    placeholderLeft.style.display = 'none';
                    resultCanvas.style.display = 'none';
                    placeholderRight.style.display = 'block';
                    statusText.innerText = "圖片已載入";
                };
                reader.readAsDataURL(file);
            }
        });

        async function runDetection() {
            if (!model || !previewImg.src) return;
            detectBtn.disabled = true;
            statusText.innerText = "正在分析多重區域...";
            
            resultCanvas.width = previewImg.naturalWidth;
            resultCanvas.height = previewImg.naturalHeight;
            
            // 先畫底圖
            const ctx = resultCanvas.getContext('2d');
            ctx.drawImage(previewImg, 0, 0, resultCanvas.width, resultCanvas.height);

            await detectAndDraw(previewImg);
            detectBtn.disabled = false;
        }

        async function detectAndDraw(imageElement) {
            const startTime = performance.now();
            const tfImg = tf.browser.fromPixels(imageElement)
                .resizeNearestNeighbor([MODEL_INPUT_SIZE, MODEL_INPUT_SIZE])
                .toFloat()
                .div(tf.scalar(255.0))
                .expandDims();

            try {
                const results = model.execute(tfImg);
                
                let output0, output1;
                // 自動偵測 Box 和 Proto Mask 輸出
                if (Array.isArray(results)) {
                    if (results[0].shape.length === 3) {
                        output0 = results[0]; output1 = results[1];
                    } else {
                        output0 = results[1]; output1 = results[0];
                    }
                } else {
                    console.error("輸出格式不符"); return;
                }

                // --- 1. 處理 Box 與 NMS (多物件關鍵) ---
                const squeezed = output0.squeeze(); 
                const transposed = squeezed.transpose([1, 0]); 
                const boxesData = await transposed.array(); // [2100, 37]

                const candidateBoxes = [];
                const candidateScores = [];
                const candidateIndices = [];

                // 篩選高分框
                for (let i = 0; i < boxesData.length; i++) {
                    let score = boxesData[i][4];
                    if (score > 1.0) score = sigmoid(score);

                    if (score > CONFIDENCE_THRESHOLD) {
                        const [cx, cy, w, h] = boxesData[i].slice(0, 4);
                        const y1 = cy - h / 2;
                        const x1 = cx - w / 2;
                        const y2 = cy + h / 2;
                        const x2 = cx + w / 2;
                        
                        candidateBoxes.push([y1, x1, y2, x2]); // NMS 需要 y1, x1, y2, x2
                        candidateScores.push(score);
                        candidateIndices.push(i);
                    }
                }

                if (candidateBoxes.length > 0) {
                    // 執行 NMS (過濾重疊)
                    const boxesTensor = tf.tensor2d(candidateBoxes);
                    const scoresTensor = tf.tensor1d(candidateScores);
                    
                    const selectedIndicesTensor = await tf.image.nonMaxSuppressionAsync(
                        boxesTensor, scoresTensor, 20, IOU_THRESHOLD, CONFIDENCE_THRESHOLD
                    );
                    const selectedIndicesMap = await selectedIndicesTensor.data(); // 這是 NMS 後的索引 (相對於 candidate 陣列)

                    // 準備 Mask 原型 (Proto)
                    const protoTensor = output1.squeeze();
                    const pShape = protoTensor.shape;
                    let maskMat, protoH, protoW;
                    
                    // 處理 Proto 形狀 [32, H, W] 或 [H, W, 32]
                    if (pShape[0] === 32) {
                        protoH = pShape[1]; protoW = pShape[2];
                        maskMat = protoTensor.reshape([32, protoH * protoW]).transpose(); 
                    } else {
                        protoH = pShape[0]; protoW = pShape[1];
                        maskMat = protoTensor.reshape([protoH * protoW, 32]);
                    }

                    const ctx = resultCanvas.getContext('2d');
                    
                    // --- 迴圈：處理每一個通過 NMS 的物件 ---
                    for (let i = 0; i < selectedIndicesMap.length; i++) {
                        const idxInCandidate = selectedIndicesMap[i]; // 取出在 candidate 中的索引
                        const originalIdx = candidateIndices[idxInCandidate]; // 取出在原始 output 中的索引
                        const score = candidateScores[idxInCandidate];
                        const box = candidateBoxes[idxInCandidate]; // [y1, x1, y2, x2] (Model 座標)

                        // 取得係數
                        const data = boxesData[originalIdx];
                        const maskCoeffs = data.slice(5, 5 + 32);
                        const coeffsTensor = tf.tensor2d(maskCoeffs, [32, 1]);

                        // 計算該物件的遮罩
                        const maskFlat = maskMat.matMul(coeffsTensor);
                        const maskActivated = tf.sigmoid(maskFlat);
                        const maskImg = maskActivated.reshape([protoH, protoW]);

                        // 繪製遮罩到 Temp Canvas
                        const maskCanvas = document.createElement('canvas');
                        maskCanvas.width = protoW;
                        maskCanvas.height = protoH;
                        await tf.browser.toPixels(maskImg, maskCanvas);

                        // 放大到結果 Canvas 大小
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = resultCanvas.width;
                        tempCanvas.height = resultCanvas.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.imageSmoothingEnabled = true;
                        
                        // 這裡可以做裁切 (Crop Mask to Box)，目前簡化為全圖繪製
                        tempCtx.drawImage(maskCanvas, 0, 0, tempCanvas.width, tempCanvas.height);

                        const imgData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                        const pixels = imgData.data;

                        // --- 2. 邊緣偵測與加粗 (Thick Edge) ---
                        const outputData = ctx.getImageData(0, 0, resultCanvas.width, resultCanvas.height);
                        const outPixels = outputData.data;
                        const width = resultCanvas.width;
                        const height = resultCanvas.height;

                        // 為了效能，我們建立一個 Set 紀錄邊界點，避免重複計算
                        const edgePoints = [];

                        // 掃描找邊界
                        for (let y = 1; y < height - 1; y++) {
                            for (let x = 1; x < width - 1; x++) {
                                const idx = (y * width + x) * 4;
                                const isMask = pixels[idx] > 128; // 判斷是否為 Mask

                                if (isMask) {
                                    // 檢查鄰居
                                    const up = pixels[((y-1) * width + x) * 4] > 128;
                                    const down = pixels[((y+1) * width + x) * 4] > 128;
                                    const left = pixels[(y * width + (x-1)) * 4] > 128;
                                    const right = pixels[(y * width + (x+1)) * 4] > 128;

                                    if (!up || !down || !left || !right) {
                                        edgePoints.push({x, y});
                                    }
                                }
                            }
                        }

                        // 繪製加粗邊界
                        const thickness = LINE_THICKNESS; 
                        // 顏色：亮黃色
                        const r=255, g=230, b=0, a=255;

                        for (let pt of edgePoints) {
                            // 對每個邊界點，塗滿周圍區域 (加粗)
                            for (let dy = -thickness; dy <= thickness; dy++) {
                                for (let dx = -thickness; dx <= thickness; dx++) {
                                    const nx = pt.x + dx;
                                    const ny = pt.y + dy;
                                    
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                        const nIdx = (ny * width + nx) * 4;
                                        outPixels[nIdx] = r;
                                        outPixels[nIdx+1] = g;
                                        outPixels[nIdx+2] = b;
                                        outPixels[nIdx+3] = a;
                                    }
                                }
                            }
                        }
                        
                        // 更新畫布上的像素
                        ctx.putImageData(outputData, 0, 0);

                        // --- 3. 繪製個別的信心指數標籤 ---
                        // 計算 Label 位置 (縮放回原圖尺寸)
                        const scaleX = resultCanvas.width / MODEL_INPUT_SIZE;
                        const scaleY = resultCanvas.height / MODEL_INPUT_SIZE;
                        
                        // box 是 [y1, x1, y2, x2]
                        const labelX = box[1] * scaleX;
                        const labelY = box[0] * scaleY;
                        
                        const labelText = `${Math.round(score * 100)}%`;
                        
                        ctx.font = "bold 20px Arial";
                        const textWidth = ctx.measureText(labelText).width;
                        const padding = 6;

                        // 繪製文字背景 (讓文字在雜亂背景中可見)
                        ctx.fillStyle = "rgba(255, 230, 0, 1)"; // 跟邊界一樣的黃色背景
                        ctx.fillRect(labelX, labelY - 30, textWidth + padding * 2, 30);
                        
                        // 繪製文字
                        ctx.fillStyle = "#000"; // 黑色文字
                        ctx.fillText(labelText, labelX + padding, labelY - 8);

                        // Cleanup Tensor loop
                        tf.dispose([coeffsTensor, maskFlat, maskActivated, maskImg]);
                    }

                    statusText.innerText = `分析完成！共偵測到 ${selectedIndicesMap.length} 個區域。`;
                    placeholderRight.style.display = 'none';
                    resultCanvas.style.display = 'block';
                    
                    // Cleanup
                    tf.dispose([boxesTensor, scoresTensor, selectedIndicesTensor, protoTensor, maskMat]);

                } else {
                    statusText.innerText = "未偵測到任何淹水區域。";
                }

                tf.dispose([output0, output1, squeezed, transposed, tfImg]);

            } catch (err) {
                console.error(err);
                statusText.innerText = "運算錯誤：" + err.message;
                tf.dispose(tfImg);
            }
        }
    </script>
</body>
</html>
