<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 淹水分割系統 (Segmentation)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>

    <style>
        /* --- 優雅風格 (White Theme) --- */
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            background-color: #ffffff;
            color: #333;
            margin: 0;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            font-weight: 300;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .main-container {
            width: 95%;
            max-width: 1000px;
            background: #fff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
            text-align: center;
        }

        .controls {
            margin: 20px 0;
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        button, input[type="file"]::file-selector-button {
            background-color: #f8f9fa;
            border: 1px solid #e2e6ea;
            border-radius: 6px;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #555;
        }

        button:hover, input[type="file"]::file-selector-button:hover {
            background-color: #e9ecef;
            color: #333;
        }

        button.primary {
            background-color: #333;
            color: #fff;
            border: none;
        }
        button.primary:hover {
            background-color: #555;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status {
            margin-top: 15px;
            font-size: 14px;
            color: #666;
            min-height: 20px;
        }

        /* --- 左右對照佈局 --- */
        .comparison-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
        }

        .img-wrapper {
            flex: 1;
            min-width: 300px;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .img-box {
            width: 100%;
            min-height: 200px;
            border: 2px dashed #eee;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 10px;
            background: #fafafa;
        }

        .img-label {
            font-weight: bold;
            margin-bottom: 8px;
            color: #555;
        }

        /* 圖片大小控制 */
        img#preview, canvas#result-canvas {
            max-width: 100%;
            max-height: 250px; /* 依照您的要求，限制高度 */
            display: none;
            border-radius: 4px;
            object-fit: contain;
        }

        canvas#result-canvas {
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>

    <div class="main-container">
        <h1>AI 淹水分割偵測</h1>
        <p style="color:#888; font-size: 0.9em;">系統將在右側繪製出淹水邊緣</p>

        <div class="controls">
            <input type="file" id="uploadInput" accept="image/*">
            <button class="primary" id="detectBtn" onclick="runDetection()" disabled>開始分析</button>
        </div>

        <div class="status" id="statusText">等待模型載入...</div>

        <div class="comparison-container">
            <div class="img-wrapper">
                <div class="img-label">原始圖片</div>
                <div class="img-box">
                    <span id="placeholder-left" style="color: #ccc;">預覽圖</span>
                    <img id="preview" alt="Original Image" />
                </div>
            </div>

            <div class="img-wrapper">
                <div class="img-label">偵測結果 (Segmentation)</div>
                <div class="img-box">
                    <span id="placeholder-right" style="color: #ccc;">等待執行...</span>
                    <canvas id="result-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ================= 設定區 =================
        const MODEL_URL = './best_web_model/model.json';
        const MODEL_INPUT_SIZE = 320; 
        const CONFIDENCE_THRESHOLD = 0.4;
        // ==========================================

        let model;
        const statusText = document.getElementById('statusText');
        const uploadInput = document.getElementById('uploadInput');
        const previewImg = document.getElementById('preview');
        const resultCanvas = document.getElementById('result-canvas');
        const detectBtn = document.getElementById('detectBtn');
        const placeholderLeft = document.getElementById('placeholder-left');
        const placeholderRight = document.getElementById('placeholder-right');

        const sigmoid = (x) => 1 / (1 + Math.exp(-x));

        async function loadModel() {
            try {
                statusText.innerText = "正在載入分割模型...";
                model = await tf.loadGraphModel(MODEL_URL);
                
                // Warmup
                const dummy = tf.zeros([1, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE, 3]);
                model.execute(dummy);
                tf.dispose(dummy);

                console.log("模型載入成功");
                statusText.innerText = "模型準備就緒，請上傳圖片。";
                detectBtn.disabled = false;
            } catch (error) {
                console.error("載入失敗:", error);
                statusText.innerText = "錯誤：無法載入模型 (請檢查路徑)";
            }
        }
        loadModel();

        uploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    previewImg.src = e.target.result;
                    previewImg.style.display = 'block';
                    placeholderLeft.style.display = 'none';
                    
                    // 重置右側
                    resultCanvas.style.display = 'none';
                    placeholderRight.style.display = 'block';
                    statusText.innerText = "圖片已載入";
                };
                reader.readAsDataURL(file);
            }
        });

        async function runDetection() {
            if (!model || !previewImg.src) return;
            detectBtn.disabled = true;
            statusText.innerText = "正在分析影像...";
            
            // 設定 Canvas 大小
            resultCanvas.width = previewImg.naturalWidth;
            resultCanvas.height = previewImg.naturalHeight;
            
            // 繪製底圖到右側 Canvas (若想看純黃線可註解此行，但通常會畫在圖上)
            const ctx = resultCanvas.getContext('2d');
            ctx.drawImage(previewImg, 0, 0, resultCanvas.width, resultCanvas.height);

            await detectAndDraw(previewImg);
            detectBtn.disabled = false;
        }

        async function detectAndDraw(imageElement) {
            const startTime = performance.now();
            const tfImg = tf.browser.fromPixels(imageElement)
                .resizeNearestNeighbor([MODEL_INPUT_SIZE, MODEL_INPUT_SIZE])
                .toFloat()
                .div(tf.scalar(255.0))
                .expandDims();

            try {
                const results = model.execute(tfImg);
                
                // 判斷輸出順序
                let output0, output1;
                // output0: Boxes [1, 37, N]
                // output1: Masks [1, 32, H, W] OR [1, H, W, 32]
                if (Array.isArray(results)) {
                    if (results[0].shape.length === 3) {
                        output0 = results[0]; output1 = results[1];
                    } else {
                        output0 = results[1]; output1 = results[0];
                    }
                } else {
                    console.error("輸出格式不符"); return;
                }

                // --- 1. 找出最佳框 (Max Score) ---
                const squeezed = output0.squeeze(); 
                const transposed = squeezed.transpose([1, 0]); 
                const boxesData = await transposed.array();

                let maxScore = -Infinity;
                let bestIdx = -1;

                for (let i = 0; i < boxesData.length; i++) {
                    const data = boxesData[i];
                    let score = data[4]; 
                    if (score > 1.0) score = sigmoid(score);

                    if (score > maxScore) {
                        maxScore = score;
                        bestIdx = i;
                    }
                }

                if (bestIdx !== -1 && maxScore > CONFIDENCE_THRESHOLD) {
                    const bestData = boxesData[bestIdx];
                    // 取得 Mask Coefficients (最後32個)
                    const maskCoeffs = bestData.slice(5, 5 + 32); 
                    const coeffsTensor = tf.tensor2d(maskCoeffs, [32, 1]);

                    // --- 2. 處理遮罩 (修復矩陣形狀錯誤) ---
                    const protoTensor = output1.squeeze(); // [32, H, W] 或 [H, W, 32]
                    const shape = protoTensor.shape;
                    
                    let maskMat; // 這是我們準備拿來跟 Coeffs 相乘的大矩陣
                    let protoH, protoW;

                    // 【關鍵修正】自動判斷 32 通道在哪個位置
                    if (shape[0] === 32) {
                        // 格式: [32, H, W] (NCHW)
                        // 需要轉置成 [H*W, 32]
                        protoH = shape[1];
                        protoW = shape[2];
                        maskMat = protoTensor.reshape([32, protoH * protoW]).transpose(); 
                    } else if (shape[shape.length - 1] === 32) {
                        // 格式: [H, W, 32] (NHWC) - 您遇到的情況應該是這種
                        // 直接 Reshape 成 [H*W, 32] 即可
                        protoH = shape[0];
                        protoW = shape[1];
                        maskMat = protoTensor.reshape([protoH * protoW, 32]);
                    } else {
                        throw new Error(`無法識別遮罩原型形狀: ${shape}`);
                    }

                    // 矩陣相乘: [N, 32] x [32, 1] = [N, 1]
                    const maskFlat = maskMat.matMul(coeffsTensor);
                    const maskActivated = tf.sigmoid(maskFlat);
                    const maskImg = maskActivated.reshape([protoH, protoW]);

                    // --- 3. 繪製與邊緣處理 ---
                    const maskCanvas = document.createElement('canvas');
                    maskCanvas.width = protoW;
                    maskCanvas.height = protoH;
                    await tf.browser.toPixels(maskImg, maskCanvas);

                    // 放大到原圖尺寸
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = resultCanvas.width;
                    tempCanvas.height = resultCanvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.imageSmoothingEnabled = true;
                    tempCtx.drawImage(maskCanvas, 0, 0, tempCanvas.width, tempCanvas.height);

                    const imgData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    const pixels = imgData.data;

                    const ctx = resultCanvas.getContext('2d');
                    const outputData = ctx.getImageData(0, 0, resultCanvas.width, resultCanvas.height);
                    const outPixels = outputData.data;

                    const width = tempCanvas.width;
                    const height = tempCanvas.height;

                    // 簡單邊緣偵測迴圈
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const i = (y * width + x) * 4;
                            const isMask = pixels[i] > 128; // 判斷是否為掩碼區域

                            if (isMask) {
                                // 檢查鄰居 (上下左右)
                                const up = pixels[((y-1) * width + x) * 4] > 128;
                                const down = pixels[((y+1) * width + x) * 4] > 128;
                                const left = pixels[(y * width + (x-1)) * 4] > 128;
                                const right = pixels[(y * width + (x+1)) * 4] > 128;

                                if (!up || !down || !left || !right) {
                                    // 這是邊緣 -> 畫不透明黃色
                                    outPixels[i] = 255;   // R
                                    outPixels[i+1] = 215; // G
                                    outPixels[i+2] = 0;   // B
                                    outPixels[i+3] = 255; // Alpha
                                } else {
                                    // 這是內部 -> 畫淡黃色透明 (可選)
                                    outPixels[i] = 255;
                                    outPixels[i+1] = 215;
                                    outPixels[i+2] = 0;
                                    outPixels[i+3] = 40;  // 降低透明度
                                }
                            }
                        }
                    }
                    ctx.putImageData(outputData, 0, 0);

                    statusText.innerText = `分析完成！(信心分數: ${Math.round(maxScore*100)}%)`;
                    placeholderRight.style.display = 'none';
                    resultCanvas.style.display = 'block';

                    // Cleanup
                    tf.dispose([coeffsTensor, protoTensor, maskMat, maskFlat, maskActivated, maskImg]);
                } else {
                    statusText.innerText = "未偵測到淹水區域。";
                }

                // Cleanup main
                tf.dispose(results);
                tf.dispose([tfImg, squeezed, transposed]);

            } catch (err) {
                console.error(err);
                statusText.innerText = "錯誤：" + err.message;
                tf.dispose(tfImg);
            }
        }
    </script>
</body>
</html>
